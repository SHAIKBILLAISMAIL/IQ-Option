import axios from 'axios';

export type MarketData = {
  symbol: string;
  name: string;
  price: number;
  bid: number;
  ask: number;
  spread: number;
  change: number;
  changePercent: number;
  high: number;
  low: number;
  volume: number;
  timestamp: number;
};

export type AssetType = 'stock' | 'forex' | 'crypto' | 'index' | 'commodity';

// Free API providers
const FINNHUB_API_KEY = process.env.NEXT_PUBLIC_FINNHUB_API_KEY || 'demo';
const TWELVE_DATA_API_KEY = process.env.NEXT_PUBLIC_TWELVE_DATA_API_KEY || '';

// Finnhub for stocks, forex, and indices
export async function getFinnhubQuote(symbol: string): Promise<MarketData | null> {
  try {
    const response = await axios.get(
      `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`
    );
    
    const data = response.data;
    
    if (!data.c || data.c === 0) return null;
    
    const price = data.c; // Current price
    const open = data.o; // Open price
    const high = data.h; // High price
    const low = data.l; // Low price
    const prevClose = data.pc; // Previous close
    
    const change = price - prevClose;
    const changePercent = ((change / prevClose) * 100);
    
    // Simulate bid/ask spread (0.1% spread)
    const spreadPercent = 0.001;
    const spread = price * spreadPercent;
    const bid = price - (spread / 2);
    const ask = price + (spread / 2);
    
    return {
      symbol,
      name: symbol,
      price,
      bid,
      ask,
      spread,
      change,
      changePercent,
      high,
      low,
      volume: 0,
      timestamp: data.t * 1000 || Date.now(),
    };
  } catch (error) {
    console.error('Finnhub error:', error);
    return null;
  }
}

// CoinGecko for crypto (free, no auth required)
export async function getCoinGeckoPrice(coinId: string): Promise<MarketData | null> {
  try {
    const response = await axios.get(
      `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_market_cap=true&include_24hr_vol=true&include_24hr_change=true&include_last_updated_at=true`
    );
    
    const data = response.data[coinId];
    if (!data) return null;
    
    const price = data.usd;
    const changePercent = data.usd_24h_change || 0;
    const change = (changePercent / 100) * price;
    
    // Simulate bid/ask spread (0.2% for crypto)
    const spreadPercent = 0.002;
    const spread = price * spreadPercent;
    const bid = price - (spread / 2);
    const ask = price + (spread / 2);
    
    return {
      symbol: coinId.toUpperCase(),
      name: coinId,
      price,
      bid,
      ask,
      spread,
      change,
      changePercent,
      high: price * 1.02, // Estimate
      low: price * 0.98, // Estimate
      volume: data.usd_24h_vol || 0,
      timestamp: data.last_updated_at * 1000 || Date.now(),
    };
  } catch (error) {
    console.error('CoinGecko error:', error);
    return null;
  }
}

// Symbol mapping for different asset types
const SYMBOL_MAPPINGS: Record<string, { type: AssetType; apiSymbol: string; provider: string }> = {
  // Indices (Finnhub)
  'US 100': { type: 'index', apiSymbol: '^NDX', provider: 'finnhub' },
  'US 30': { type: 'index', apiSymbol: '^DJI', provider: 'finnhub' },
  'US 2000': { type: 'index', apiSymbol: '^RUT', provider: 'finnhub' },
  'US 500': { type: 'index', apiSymbol: '^GSPC', provider: 'finnhub' },
  'GER 30': { type: 'index', apiSymbol: '^GDAXI', provider: 'finnhub' },
  'JP 225': { type: 'index', apiSymbol: '^N225', provider: 'finnhub' },
  'FR 40': { type: 'index', apiSymbol: '^FCHI', provider: 'finnhub' },
  'UK 100': { type: 'index', apiSymbol: '^FTSE', provider: 'finnhub' },
  
  // Forex (Finnhub uses OANDA format)
  'EUR/USD': { type: 'forex', apiSymbol: 'OANDA:EUR_USD', provider: 'finnhub' },
  'GBP/USD': { type: 'forex', apiSymbol: 'OANDA:GBP_USD', provider: 'finnhub' },
  'USD/JPY': { type: 'forex', apiSymbol: 'OANDA:USD_JPY', provider: 'finnhub' },
  'AUD/USD': { type: 'forex', apiSymbol: 'OANDA:AUD_USD', provider: 'finnhub' },
  'USD/CAD': { type: 'forex', apiSymbol: 'OANDA:USD_CAD', provider: 'finnhub' },
  'USD/CHF': { type: 'forex', apiSymbol: 'OANDA:USD_CHF', provider: 'finnhub' },
  
  // Crypto (CoinGecko)
  'Bitcoin': { type: 'crypto', apiSymbol: 'bitcoin', provider: 'coingecko' },
  'Ethereum': { type: 'crypto', apiSymbol: 'ethereum', provider: 'coingecko' },
  'Ripple': { type: 'crypto', apiSymbol: 'ripple', provider: 'coingecko' },
  'Litecoin': { type: 'crypto', apiSymbol: 'litecoin', provider: 'coingecko' },
  'Cardano': { type: 'crypto', apiSymbol: 'cardano', provider: 'coingecko' },
  
  // Stocks (Finnhub)
  'Apple': { type: 'stock', apiSymbol: 'AAPL', provider: 'finnhub' },
  'Microsoft': { type: 'stock', apiSymbol: 'MSFT', provider: 'finnhub' },
  'Tesla': { type: 'stock', apiSymbol: 'TSLA', provider: 'finnhub' },
  'Amazon': { type: 'stock', apiSymbol: 'AMZN', provider: 'finnhub' },
  'Google': { type: 'stock', apiSymbol: 'GOOGL', provider: 'finnhub' },
  'Meta': { type: 'stock', apiSymbol: 'META', provider: 'finnhub' },
};

// Get market data for any asset
export async function getMarketData(displayName: string): Promise<MarketData | null> {
  const mapping = SYMBOL_MAPPINGS[displayName];
  
  if (!mapping) {
    console.warn(`No mapping found for ${displayName}`);
    return null;
  }
  
  try {
    if (mapping.provider === 'coingecko') {
      return await getCoinGeckoPrice(mapping.apiSymbol);
    } else if (mapping.provider === 'finnhub') {
      return await getFinnhubQuote(mapping.apiSymbol);
    }
    
    return null;
  } catch (error) {
    console.error(`Error fetching data for ${displayName}:`, error);
    return null;
  }
}

// Batch fetch multiple assets
export async function getBatchMarketData(symbols: string[]): Promise<Record<string, MarketData | null>> {
  const results = await Promise.allSettled(
    symbols.map(async (symbol) => {
      const data = await getMarketData(symbol);
      return { symbol, data };
    })
  );
  
  const dataMap: Record<string, MarketData | null> = {};
  
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      dataMap[symbols[index]] = result.value.data;
    } else {
      dataMap[symbols[index]] = null;
    }
  });
  
  return dataMap;
}

// Generate realistic price movement for simulation when APIs fail
export function simulatePriceMovement(basePrice: number, volatility: number = 0.001): number {
  const change = (Math.random() - 0.5) * 2 * volatility;
  return basePrice * (1 + change);
}
